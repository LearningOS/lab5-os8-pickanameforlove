### 实验总结

首先重写sys_get_time和sys_task_info这两个系统调用。改进的地方是将传入的虚拟地址翻译成物理地址，使用当前任务的地址空间翻译。

然后就是sys_mmap和sys_munmap两个系统调用，这其中最核心的是判断一个虚拟页号是否已经映射了。通过TaskManager找到当前任务，通过它的地址空间memory_set判断是否包含虚拟页号。地址空间由多个逻辑段组成，遍历这些逻辑段一个个判断是否包含指定的逻辑页。逻辑段既可以通过起止页号来判断，也可以使用物理帧和逻辑页的map来进行判断。

进行判断之后，对Vec\<MapArea\>和PageTable进行更新（添加/删除）。

### 问答作业

1. SV39页表项包括如下：
   * 10位的保留位，
   * 44位的物理页号，这里分成三部分，分别是26位，9位，9位。这里是因为实现了多级页表的原因，一张页表4KB，一个页表项8B，那么一个页表可以包含512个页表项，即$2^9$。
   * 然后是两位的RSW，这两位留给S Mode的应用程序。
   * 然后是8位标志位，D，记录自从页表项上的这一位被清零之后，页表项对应的虚拟页表是否被修改过；
   * A，记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；
   * G，如果等于1，则表示这个页表项是全局的，也就是所有的页表都包含这一项；
   * U控制索引到这个页表项的对应虚拟页面是否是用户可访问的；
   * X/W/R分别控制这个页表项对应的虚拟页面是否允许取指/写/读。
   * V表示页表项是否合法。
2.  1）不清楚；2）stval寄存器会记录缺页异常的相关信息。3）lazy策略可以减少访存次数，增大一次访存获取的数据。4）大概是20MB大小。5）缺页时立即调入对应的物理帧，但同时也将之前累计没有调入的物理帧进行调入。6）将页表项有效位置为0.
3. 1）从用户态切换到内核态；2）内核页面仅仅内核态可以访问；3）不会涉及到用户地址空间和内核地址空间的切换；4）双页表更换：进程调用系统调用，需要内核处理的时候；单页表更换：进行中断处理之前，设置为内核态。



