### 实验总结

lab1要求实现一个获取当前任务的taskinfo的系统调用。为了实现该功能，为每个任务的TaskControlBlock添加了两个属性，一个属性描述该任务开始执行的时间，一个属性描述该任务使用的系统调用及其次数，用一个大小为500的列表实现。

任务开始执行的时间初始化为0，在任务从UnInit状态转为Running状态的时候，使用框架提供的get_time()函数进行修改。而系统调用相关的信息在调用系统调用的时候进行更新，也就是在syscall目录下的mod.rs文件中进行更新。

### 问答题

1. 使用的SBI为RUSTSBI 0.1.1。下面是报错信息。

![image-20220728191221054](pic/image-20220728191221054.png)

第一行的报错信息显示，找不到0x0的地址。

第二行的报错信息显示，使用了非法指令。从代码中显示为```sret```

第三行的报错信息显示，使用了非法指令。从代码中显示为```csrr {}, sstatus```

2.1 a0应该代表的是内核栈的栈顶。使用的场景主要是：1）trap处理之后返回用户态；2）通过__restore开始运行app。

2.2 t0里面是CSR sstatus的值。其中的SPP字段给出了Trap发生之前CPU处于哪个特权级。t1里面是CSR spec的值。当trap是一个异常的时候，sepc记录Trap发生之前执行的最后一条指令的地址。t2里面是用户栈栈顶的地址。

2.3 x2寄存器即为sp（栈顶指针），在前面的汇编代码中已经读到了sscratch中。x4寄存器，用户程序用不到，所以没有存，也不需要取。

2.4 交换了sp和sscratch的值。执行完之后，sp指向用户栈栈顶，sscratch指向内核栈栈顶。

2.5 sret指令之后，进入用户态。```sret```指令会执行以下功能：

CPU将当前的特权级按照sstatus的SPP字段设置为U或S。

CPU会跳转到```spec```寄存器指向的那条指令，然后继续执行

2.6 L13指令执行完之后，sp指向了内核栈栈顶，sscratch指向了用户栈栈顶。

2.7 ```call trap_handler```这条指令使机器从U态进入S态。